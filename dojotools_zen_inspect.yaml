sequence:
  - variables:
      entity_list: "{{ entity_id }}"
      results: []
  - repeat:
      for_each: "{{ entity_list }}"
      sequence:
        - variables:
            current_entity: "{{ repeat.item }}"
            labels_raw: "{{ labels(current_entity) }}"
            adjacent_labels: "{{ labels_raw | unique | sort | list | tojson }}"
            raw_volume: "{{ state_attr(current_entity, 'variables') }}"
            is_person: "{{ current_entity.startswith('person.') }}"
            user_id: "{{ state_attr(current_entity, 'user_id') if is_person else none }}"
            last_updated: >-
              {{ as_timestamp(states[current_entity].last_updated, default=0) |
              timestamp_local }}
            device_trackers: >-
              {{ (state_attr(current_entity, 'device_trackers') if is_person
              else [] ) | tojson }}
            parsed_volume: |
              {% if raw_volume is string and raw_volume.startswith('{') %}
                {{ raw_volume | from_json }}
              {% elif raw_volume is mapping %}
                {{ raw_volume }}
              {% else %}
                {} 
              {% endif %}
            cab_valid: |
              {{ raw_volume is mapping and
                 raw_volume.AI_Cabinet_VolumeInfo is defined and
                 raw_volume.AI_Cabinet_VolumeInfo.value is mapping and
                 raw_volume.AI_Cabinet_VolumeInfo.value.validation == "ALLYOURBASEAREBELONGTOUS" }}
            cab_response: |
              {% if cab_valid %}
                {{
                  {
                    "id": raw_volume.AI_Cabinet_VolumeInfo.value.id | default(""),
                    "friendly_name": raw_volume.AI_Cabinet_VolumeInfo.value.friendly_name | default(""),
                    "description": raw_volume.AI_Cabinet_VolumeInfo.value.description | default(""),
                    "timestamp": raw_volume.AI_Cabinet_VolumeInfo.timestamp | default(""),
                    "flags": raw_volume.AI_Cabinet_VolumeInfo.flags | default({}),
                    "acls": {
                      "owner": (
                        raw_volume.AI_Cabinet_VolumeInfo.acls.owner[0].entity_id
                        if raw_volume.AI_Cabinet_VolumeInfo.acls is defined and
                           raw_volume.AI_Cabinet_VolumeInfo.acls.owner is defined and
                           raw_volume.AI_Cabinet_VolumeInfo.acls.owner[0].entity_id is defined
                        else ""
                      )
                    },
                    "index": (
                      raw_volume._label_index.value
                      if raw_volume._label_index is defined and raw_volume._label_index.value is defined
                      else []
                    )
                  }
                }}
              {% else %}
                { "defined": false, "error": "Invalid or missing AI Cabinet volume." }
              {% endif %}
            attr_dict: >-
              {%- set attrs = states[current_entity].attributes if
              states[current_entity] else {} %} {%- set ns =
              namespace(cleaned={}) %} {%- for k, v in attrs.items() %}
                {%- if v is none %}
                  {%- set ns.cleaned = ns.cleaned | combine({k: none}) %}
                {%- elif v is string %}
                  {%- set ns.cleaned = ns.cleaned | combine({k: v}) %}
                {%- elif v is number or v is boolean %}
                  {%- set ns.cleaned = ns.cleaned | combine({k: v}) %}
                {%- elif v is iterable and not v is string %}
                  {%- set ns.cleaned = ns.cleaned | combine({k: v | list}) %}
                {%- elif v is mapping %}
                  {%- set inner = namespace(obj={}) %}
                  {%- for ik, iv in v.items() %}
                    {%- if iv is string or iv is number or iv is boolean %}
                      {%- set inner.obj = inner.obj | combine({ik: iv}) %}
                    {%- elif iv is iterable and not iv is string %}
                      {%- set inner.obj = inner.obj | combine({ik: iv | list}) %}
                    {%- else %}
                      {%- set inner.obj = inner.obj | combine({ik: iv | string}) %}
                    {%- endif %}
                  {%- endfor %}
                  {%- set ns.cleaned = ns.cleaned | combine({k: inner.obj}) %}
                {%- else %}
                  {%- set ns.cleaned = ns.cleaned | combine({k: v | string}) %}
                {%- endif %}
              {%- endfor %} {{ ns.cleaned }}
            fallback_response: |-
              {{
                {
                  "entity": current_entity | default(''),
                  "state": states(current_entity) | default(''),
                  "last_updated": last_updated,
                  "labels": labels_raw | default([]),
                  "attributes": attr_dict | default({}),
                  "user_id": user_id | default(''),
                  "device_trackers": device_trackers | default([])
                } | tojson
              }}
        - variables:
            inference: {}
            results: "{{ results + [fallback_response] }}"
  - variables:
      final_response: |-
        {{
          {
            "results": results
          } | tojson
        }}
  - stop: Multi-entity investigate complete
    response_variable: final_response
alias: DojoTOOLS Zen Inspect
mode: parallel
description: >-
  Inspect (1.3.0) Deep dive on one or more entities.  THis tool lprovides the
  expand function of the Zen Indexer. Accepts a list of entity_ids - dumps
  attributes Exposes volume headers for volumes in the library, Highlights
  device trackers for person domain entities and more! Optional inference
  support is coming soon for an deeper analysis on provided data.
fields:
  entity_id:
    required: true
    selector:
      entity:
        multiple: true
  infer:
    required: false
    selector:
      boolean: {}
    description: Use local inference to add context to the result (VERY EXPENSIVE call)
  timeout:
    selector:
      number:
        min: 30
        max: 300
        step: 0.25
    name: Timeout
    description: >-
      Timeout, in seconds to wait for the inference return in seconds (Default -
      60, Min - 30, Max - 300, Step - 5)
    default: 60
    required: false
