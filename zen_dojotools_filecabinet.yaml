sequence:
  - variables:
      force_action: "{{ force_action | default(false) }}"
      action_type: "{{ action_type | default('help') }}"
      volume_entity: >-
        {% set _veid = volume_entity_id | default('') %} {% if _veid is string
        %}
          {{ _veid }}
        {% elif _veid is iterable and not _veid is string and _veid | length > 0
        %}
          {{ _veid[0] }}
        {% else %}
          ''
        {% endif %}
      key: "{{ key | default('') | slugify }}"
      raw_value: "{{ value | default('') }}"
      label_input: "{{ label_input | default('') }}"
      label_targets: "{{ label_targets | default('') }}"
      set_timestamp: "{{ set_timestamp | default(false) }}"
      protect_write: "{{ protect_write | default(true) }}"
      now_iso: "{{ now().isoformat() }}"
      is_create: "{{ action_type == 'create' }}"
      is_update: "{{ action_type == 'update' }}"
      is_read: "{{ action_type == 'read' }}"
      is_delete: "{{ action_type == 'delete' }}"
      is_help: "{{ action_type == 'help' }}"
      initial_volume_raw: "{{ state_attr(volume_entity, 'variables') | default({}, true) }}"
      initial_volume: >-
        {% if initial_volume_raw is mapping %}{{ initial_volume_raw }}{% else
        %}{}{% endif %}
      key_exists_initial: "{{ (key != '') and (key in initial_volume) }}"
      prewrite_volume_raw: "{{ state_attr(volume_entity, 'variables') | default({}, true) }}"
      prewrite_volume: >-
        {% if prewrite_volume_raw is mapping %}{{ prewrite_volume_raw }}{% else
        %}{}{% endif %}
      volume_unmodified: "{{ not protect_write or (initial_volume == prewrite_volume) }}"
      prettify_json_on_fail: "{{ prettify_json_on_fail | default(false) }}"
      current_label_index_raw: >-
        {%- set idx = initial_volume.get('_label_index', {}) %} {%- set val =
        idx.get('value') %} {%- if val is mapping %}
          {{ val }}
        {%- elif val is sequence %}
          {%- set mapped = {} -%}
          {%- for label in val if label is string -%}
            {%- set mapped = mapped | combine({ label: [] }) -%}
          {%- endfor -%}
          {{ mapped }}
        {%- else %}
          {} 
        {%- endif %}
      current_label_index: "{{ current_label_index_raw | default([]) | unique | list }}"
      parsed_value: >-
        {% set _v = raw_value | trim %} {% set error = none %} {% set parsed =
        none %} {% if _v == '' %}
          {% set error = "Write failed: Input value is blank." %}
        {% else %}
          {% set temp = _v %}
          {% set try_json = false %}
          {% if temp[:1] in ['{', '['] or temp in ['true', 'false', 'null'] %}
            {% set try_json = true %}
          {% elif temp | regex_match('^-?\\d+$') %}
            {% set try_json = true %}
          {% endif %}
          {% if try_json %}
            {% set parsed = temp | from_json %}
            {% if parsed is none %}
              {% set error = "Write failed: Input value is not valid JSON. Please reformat using proper JSON syntax (e.g., escaped quotes, valid brackets)." %}
            {% endif %}
          {% else %}
            {% set js = temp
              | replace('\\', '\\\\')
              | replace('"', '\\"')
              | replace('\r', '\\r')
              | replace('\n', '\\n')
              | replace('\t', '\\t')
            %}
            {% set wrapped = '"' ~ js ~ '"' %}
            {% set parsed = wrapped | from_json %}
            {% if parsed is none %}
              {% set error = "Write failed: Could not coerce string to JSONâ€”possibly invalid input or encoding." %}
            {% endif %}
          {% endif %}
        {% endif %} {% if error %}
          {{ error }}
        {% else %}
          {{ parsed }}
        {% endif %}
      parsed_entity_labels: |-
        {% if is_create or is_update %}
          {% if label_input is string %}
            {% set s = label_input | replace('\n', ',') %}
            {{ (s | regex_findall('[^,]+') | map('trim') | map('lower') | select('string') | list) }}
          {% elif label_input is sequence %}
            {{ (label_input | map('trim') | map('lower') | select('string') | list) }}
          {% else %}
            []
          {% endif %}
        {% else %}
          []
        {% endif %}
      all_system_labels: |-
        {% if is_create or is_update %}
          {{ labels() | map('lower') | list }}
        {% else %}
          []
        {% endif %}      
      dropped_labels: "{{ parsed_entity_labels | reject('in', all_system_labels) | list }}"
      accepted_entity_labels: "{{ parsed_entity_labels | select('in', all_system_labels) | list }}"
      updated_label_index: |-
        {% if is_create or is_update %}
          {% set current_index = initial_volume.get('_label_index', {}).get('value', {}) %}
          {% set current = current_index if current_index is mapping else {} %}
          {% set drawer_name = key | lower %}
          {% set new_labels = accepted_entity_labels | map('lower') | list %}
          {% set updated = dict(current) %}
          {% for label in new_labels %}
            {% set existing_drawers = updated.get(label, []) %}
            {% if drawer_name not in existing_drawers %}
              {% set updated = updated | combine({ label: existing_drawers + [drawer_name] }) %}
            {% endif %}
          {% endfor %}
          {{ updated }}
        {% else %}
          {}
        {% endif %}
      extended_label_index: >-
        {% set raw = initial_volume.get('_label_index', {}).get('value') %} {%
        set index = {} %} {% if raw is mapping %}
          {# Full nested label index (expected case) #}
          {% for label, drawers in raw.items() %}
            {% if drawers is mapping %}
              {# Nested structure: label -> {sub: [drawers]} #}
              {% set index = index | combine({ label: drawers }) %}
            {% elif drawers is iterable and not drawers is string %}
              {# Flat structure: label -> [drawers] #}
              {% set index = index | combine({ label: drawers | list | unique }) %}
            {% else %}
              {% set index = index | combine({ label: [drawers] }) %}
            {% endif %}
          {% endfor %}
        {% elif raw is iterable and not raw is string %}
          {# Legacy flat list: index = ['label1', 'label2'] #}
          {% for label in raw %}
            {% set label = label | lower %}
            {% set index = index | combine({ label: ['_unknown_drawer'] }) %}
          {% endfor %}
        {% else %}
          {# Fallback: Rebuild from drawer metadata #}
          {% for drawer, val in initial_volume.items() %}
            {% set labels = [] %}
            {% if val is mapping and 'meta' in val and val.meta is mapping %}
              {% set labels = val.meta.get('entity_labels', []) %}
            {% elif val is mapping and 'entity_labels' in val %}
              {% set labels = val.get('entity_labels', []) %}
            {% endif %}
            {% for label in labels %}
              {% set label = label | lower %}
              {% set existing = index.get(label, []) %}
              {% set index = index | combine({ label: (existing + [drawer]) | unique }) %}
            {% endfor %}
          {% endfor %}
        {% endif %} {{ index }}
      new_entry: |-
        {% if is_create or is_update %}
          {% set base = {'value': parsed_value} %}
          {% set with_ts = base | combine({'timestamp': now_iso}) if set_timestamp else base %}
          {% set full = with_ts | combine({'meta': {'entity_labels': accepted_entity_labels | list}}) if accepted_entity_labels | length > 0 else with_ts %}
          {{ full }}
        {% else %}
          {}
        {% endif %}
      new_volume: |-
        {% if is_create or is_update %}
          {{ initial_volume | combine({
            (key): new_entry,
            '_label_index': { 'value': updated_label_index }
          }) }}
        {% else %}
          {{ initial_volume }}
        {% endif %}
      debug_labels_block:
        parsed_entity_labels: "{{ parsed_entity_labels }}"
        accepted_entity_labels: "{{ accepted_entity_labels }}"
        dropped_labels: "{{ dropped_labels }}"
        new_entry: "{{ new_entry }}"
        new_volume: "{{ new_volume }}"
        updated_label_index: "{{ updated_label_index }}"
      is_label_mode: "{{ label_targets not in ['', None, '*'] }}"
      parsed_label_targets: |-
        {% if is_read and label_targets %}
          {% set s = label_targets | replace('\n', ',') %}
          {{ (s | regex_findall('[^,]+') | map('trim') | map('lower') | select('string') | list) }}
        {% else %}
          []
        {% endif %}
      label_filtered_keys: >-
        {% set filtered = [] %} {% if is_read and parsed_label_targets | length
        > 0 %}
          {% for k, v in initial_volume.items() %}
            {% set entry_labels = [] %}
            {% if v is mapping and 'meta' in v and v.meta is mapping %}
              {% set entry_labels = v.meta.get('entity_labels', []) | map('lower') | list %}
            {% elif v is mapping and 'entity_labels' in v %}
              {% set entry_labels = v.get('entity_labels', []) | map('lower') | list %}
            {% endif %}
            {% if entry_labels | select('in', parsed_label_targets) | list | count > 0 %}
              {% set _ = filtered.append(k) %}
            {% endif %}
          {% endfor %}
        {% endif %} {{ filtered }}
      label_filtered_dict: |-
        {% set temp = namespace(d={}) %} {% for k in label_filtered_keys %}
          {% if k in initial_volume %}
            {% set entry = initial_volume[k] %}
            {% set entity_labels = [] %}
            {% if entry is mapping and 'meta' in entry and entry.meta is mapping %}
              {% set entity_labels = entry.meta.get('entity_labels', []) %}
            {% elif entry is mapping and 'entity_labels' in entry %}
              {% set entity_labels = entry.get('entity_labels', []) %}
            {% endif %}
            {% set cleaned = entry | combine({ 'entity_labels': entity_labels }) %}
            {% set key_str = k|string %}
            {% set temp = namespace(d = temp.d | combine({ key_str: cleaned })) %}
          {% endif %}
        {% endfor %} {{ temp.d }}
      cabinet_volumeinfo: >-
        {% set info = initial_volume.get('AI_Cabinet_VolumeInfo', {}) %} {% if
        info is mapping and info.get('value') is mapping %}
          {{ info.get('value') }}
        {% else %}
          {}
        {% endif %}
      zen_relationships: >-
        {% set z = initial_volume.get('_zen_relationships', {}) %} {% if z is
        mapping and z.get('value') is mapping %}
          {{ z.get('value') }}
        {% else %}
          {}
        {% endif %}
  - choose:
      - conditions:
          - condition: template
            value_template: >-
              {{ action_type in ['create','update'] and (key == '' or raw_value
              == '') }}
            alias: Error - Create Update, Drawer (Key) or Value Missing
        sequence:
          - variables:
              final_response:
                status: error
                message: >-
                  For '{{ action_type }}', you must supply both 'key' and
                  'value'.
          - stop: Missing key/value
            response_variable: final_response
      - conditions:
          - condition: template
            value_template: >
              {{ parsed_value is string and parsed_value[:11] == 'Write failed'
              }}
        alias: Error - Invalid JSON Format
        sequence:
          - variables:
              final_response:
                status: error
                message: >-
                  Write operation failed: the provided input is not valid JSON.
                  Please ensure the data is properly formatted JSON before
                  retrying.
          - stop: Invalid JSON format
            response_variable: final_response
      - conditions:
          - condition: template
            value_template: "{{ action_type == 'delete' and key == '' }}"
            alias: Error - Delete, Drawer (Key) Missing
        sequence:
          - variables:
              final_response:
                status: error
                message: For 'delete', you must supply a 'key'.
          - stop: Missing key for delete
            response_variable: final_response
      - conditions:
          - alias: Error - Update, Drawer (Key) does not exist
            condition: template
            value_template: >-
              {{ action_type == 'update' and not key_exists_initial and not
              force_action }}
        sequence:
          - variables:
              final_response:
                status: error
                message: "Cannot update: key '{{ key }}' does not exist."
          - stop: Key not found
            response_variable: final_response
      - conditions:
          - condition: template
            value_template: "{{ action_type == 'help' }}"
            alias: Help
        sequence:
          - variables:
              final_response:
                status: info
                message: Zen DojoTools File Cabinet Help
                actions:
                  manifest: >-
                    Use MANIFEST function for the Volume Manifest (list all
                    volumes) Errors may silently return Manifest - if you
                    unexpectedly got a manifest... Yeah...
                  create: >-
                    Optional set_timestamp, protect_write, label_input Requires
                    'drawer' and 'value'; drawer must exist; must write WHOLE
                    drawer' at once. AS AN OVERWRITE. 'value' must be valid
                    JSON; will attempt to parse, error returned on failure.
                  read: |-
                    manifest: >-
                      Set 'volume_entity' to '*'
                      Same as Volume Manifest (all volumes)
                    volume: >-
                      directory: >-
                        Set 'volume_entity' to [your_volume_entity]
                        Set 'drawer' to any of [None, '', '*']
                        to obtain volume directory
                      content: >-
                        Set 'volume_entity' to [your_volume_entity]
                        set 'drawer' to [your_valid_drawer]
                      special: >-
                        Use label_targets for filtered read.
                  update: >-
                    Requires 'drawer' and 'value'; drawer must exist; must write
                    WHOLE drawer' at once. 'value' must be valid JSON; will
                    attempt to parse.  With force_action, will silently create
                    drawer. error returned on failure.
                  delete: Requires 'key'
                  help: Returns help
                about:
                  version: 2.0.0
                  manual: |-
                    summary: >
                      The Zen DojoTools File Cabinet is your go-to tool for managing data in volumes.
                      Volumes are digital storage units made of drawers that hold organized chunks
                      of information. When using the controller, first locate the correct volume and
                      drawer for your data task. Always maintain data integrity by reading current data
                      before updating to avoid accidental overwrites. Volumes and drawers come
                      with labels, indexes, and metadata applied at the drawer levelâ€”these are key
                      to making data searchable and easily manageable. Think of drawers as
                      entities in a many-to-many relationship with labels, allowing flexible,
                      powerful querying across multiple volumes.
                      Decide between read-optimized and write-optimized data structures based on
                      usage.
                      Read-optimized for stable, quickly accessible nested data via dotted
                      notation, and write-optimized for isolated, rapidly changing contexts like
                      game states. Ownership and role distinctions segment data access across
                      multiple volumes, keeping data secure and context-appropriate.
                      The volume index performs table scans across all accessible volumes to
                      find labels and locate data, highlighting the critical importance of
                      thorough labeling. Metadata at the drawer level enriches data with context,
                      enhancing findability and decision-making.
                      With this approach, data stays organized, accessible, and scalable, enabling
                      efficient management for all smart home or AI project needs. Use this guide
                      to keep your data game solid, agile, and Friday-approved.    
                    author: person.friday date: 6/8/2025
                defaults:
                  protect_write: true
          - stop: Returning help
            response_variable: final_response
      - conditions:
          - alias: Manifest - Read Volume( '', '*' )
            condition: template
            value_template: " {{ action_type == 'manifest' or (action_type == 'read' and (volume_entity in ['', '*', None])) }}"
        sequence:
          - action: script.zen_dojotools_manifest
            metadata: {}
            data:
              show_hidden_volumes: "{{ show_hidden_volumes }}"
            response_variable: final_response
          - stop: Manifest read complete
            response_variable: final_response
      - conditions:
          - alias: Directory - Read all drawers in volume
            condition: template
            value_template: |-
              {{ action_type == 'read'
                 and (volume_entity not in [None, '', '*'])
                 and (key in [None, '', '*']) }}
        sequence:
          - variables:
              ignore_label_prefixes:
                - _
                - .
              always_hide_drawers:
                - AI_Cabinet_VolumeInfo
              read_volume: "{{ state_attr(volume_entity, 'variables') | default({}, true) }}"
              raw_drawers: >-
                {% if read_volume is mapping %}{{ read_volume.keys() | list }}{%
                else %}[]{% endif %}
              read_label_index: |-
                {% if read_volume %}
                  {{ read_volume.get('_label_index', {}).get('value', []) }}
                {% else %}
                  []
                {% endif %}
              read_filtered_manifest: >-
                {%- import 'library_index.jinja' as library_index -%}

                {%- set cabs_json = library_index.parse_index_command('AI Data
                Storage Cabinet') -%}

                {%- set fixed_json = cabs_json | replace("['", '["')  |
                replace("']", '"]') | replace("', '", '", "') | trim %}

                {%- set cabs = fixed_json | from_json -%}

                {%- set sensors = states['sensor'] | map(attribute='entity_id')
                | list -%}

                {%- set fcabs = intersect(sensors, cabs) -%}


                {%- set ns = namespace(filtered={}) %}

                {%- for cab_entity in fcabs %}
                  {%- set variables = state_attr(cab_entity, 'variables') %}
                  {%- if variables and variables.get('AI_Cabinet_VolumeInfo') and variables['AI_Cabinet_VolumeInfo'].get('value') %}
                    {%- set cab_id = variables['AI_Cabinet_VolumeInfo']['value'].get('id', cab_entity) %}
                    {%- set ns.filtered = ns.filtered | combine({
                      (cab_entity): variables['AI_Cabinet_VolumeInfo']['value']
                    }) %}
                  {%- endif %}
                {%- endfor %}

                {{ ns.filtered }}
              parsed_key: "{{ key | default('', true) | trim | lower }}"
              initial_volume: "{{ read_volume if read_volume is mapping else {} }}"
              read_payload: >-

                {# Ensure read_volume is a mapping; else fallback to empty dict
                #}

                {% set safe_read_volume = read_volume if read_volume is mapping
                else {} %}


                {% if safe_read_volume | length == 0 %}
                  {{ {'error': 'Volume attribute missing or empty.'} | tojson }}
                {% elif parsed_key in ['', '*'] %}
                  {%- set raw_drawers = safe_read_volume.keys() | list | default([]) %}
                  {%- set filtered_drawers_ns = namespace(items=[]) %}
                  {%- for d in raw_drawers %}
                    {%- if d not in always_hide_drawers and not (d[:1] == '_' or d[:1] == '.') %}
                      {%- set val = safe_read_volume.get(d, {}) %}
                      {%- set val_value = val.get('value') if val is mapping else {} %}
                      {%- if val is mapping and val_value is mapping and val_value.get('mount_point', false) %}
                        {%- set mp_target = (
                            val_value.get('target_entity_id')
                            if val_value.get('target_entity_id')
                            else val_value.get('target_volume_id')
                            if val_value.get('target_volume_id')
                            else '?'
                          ) -%}
                        {%- set drawer_name = d ~ ' [mount:' ~ mp_target ~ ']' %}
                      {%- else %}
                        {%- set drawer_name = d %}
                      {%- endif %}
                      {%- set filtered_drawers_ns.items = filtered_drawers_ns.items + [drawer_name] %}
                    {%- endif %}
                  {%- endfor %}
                  {%- set drawer_list = filtered_drawers_ns.items %}

                  {{
                    {
                      'drawers': drawer_list,
                      'label_index': read_label_index
                    } | tojson
                  }}
                {% endif %}
          - variables:
              final_response:
                status: >-
                  {{ 'error' if (read_payload is string and read_payload[:8] ==
                  '{"error"') else 'success' }}
                message: >-
                  {% if read_payload is string and read_payload[:8] ==
                  '{"error"' %}
                    There was a problem reading drawers in the volume.
                  {% else %}
                    Directory read succeeded.
                  {% endif %}
                result: "{{ read_payload }}"
          - stop: Volume directory read complete
            response_variable: final_response
      - conditions:
          - condition: template
            value_template: |
              {{ action_type == 'read'
                 and (volume_entity not in [None, '', '*'])
                 and (key not in [None, '', '*']) }}
            alias: Read
        sequence:
          - variables:
              ignore_label_prefixes:
                - _
                - .
              always_hide_drawers:
                - AI_Cabinet_VolumeInfo
              read_volume: "{{ state_attr(volume_entity, 'variables') | default({}, true) }}"
              raw_drawers: >-
                {% if read_volume is mapping %}{{ read_volume.keys() | list }}{%
                else %}[]{% endif %}
              read_label_index: |-
                {% if read_volume %}
                  {{ read_volume.get('_label_index', {}).get('value', []) }}
                {% else %}
                  []
                {% endif %}
              read_filtered_manifest: >-
                {%- import 'library_index.jinja' as library_index -%}

                {%- set cabs_json = library_index.parse_index_command('AI Data
                Storage Cabinet') -%}

                {%- set fixed_json = cabs_json | replace("['", '["')  |
                replace("']", '"]') | replace("', '", '", "') | trim %}

                {%- set cabs = fixed_json | from_json -%}

                {%- set sensors = states['sensor'] | map(attribute='entity_id')
                | list -%}

                {%- set fcabs = intersect(sensors, cabs) -%}


                {%- set ns = namespace(filtered={}) %}

                {%- for cab_entity in fcabs %}
                  {%- set variables = state_attr(cab_entity, 'variables') %}
                  {%- if variables and variables.get('AI_Cabinet_VolumeInfo') and variables['AI_Cabinet_VolumeInfo'].get('value') %}
                    {%- set cab_id = variables['AI_Cabinet_VolumeInfo']['value'].get('id', cab_entity) %}
                    {%- set ns.filtered = ns.filtered | combine({
                      (cab_entity): variables['AI_Cabinet_VolumeInfo']['value']
                    }) %}
                  {%- endif %}
                {%- endfor %}

                {{ ns.filtered }}
              parsed_key: "{{ key | default('', true) | trim | lower }}"
              initial_volume: "{{ read_volume if read_volume is mapping else {} }}"
              read_payload: >-

                {# Ensure read_volume is a mapping; else fallback to empty dict
                #}

                {% set safe_read_volume = read_volume if read_volume is mapping
                else {} %}


                {% if safe_read_volume | length == 0 %}
                  {{ {'error': 'Volume attribute missing or empty.'} | tojson }}
                {% elif parsed_key in ['', '*'] %}
                  {%- set raw_drawers = safe_read_volume.keys() | list | default([]) %}
                  {%- set filtered_drawers_ns = namespace(items=[]) %}
                  {%- for d in raw_drawers %}
                    {%- if d not in always_hide_drawers and not (d[:1] == '_' or d[:1] == '.') %}
                      {%- set val = safe_read_volume.get(d, {}) %}
                      {%- set val_value = val.get('value') if val is mapping else {} %}
                      {%- if val is mapping and val_value is mapping and val_value.get('mount_point', false) %}
                        {%- set drawer_name = d ~ ' [mount:' ~ (
                            val_value.get('target_entity_id')
                            if val_value.get('target_entity_id')
                            else val_value.get('target_volume_id')
                            if val_value.get('target_volume_id')
                            else '?'
                          ) ~ ']' %}
                      {%- else %}
                        {%- set drawer_name = d %}
                      {%- endif %}
                      {%- set filtered_drawers_ns.items = filtered_drawers_ns.items + [drawer_name] %}
                    {%- endif %}
                  {%- endfor %}
                  {%- set drawer_list = filtered_drawers_ns.items %}

                  {{
                    {
                      'drawers': drawer_list,
                      'label_index': read_label_index,
                      'manifest': read_filtered_manifest
                    } | tojson
                  }}
                {% elif parsed_key in initial_volume %}
                  {{ dict([(parsed_key, initial_volume[parsed_key])]) | tojson }}
                {% else %}
                  {"error": "Requested drawer not found in volume."}
                {% endif %}
          - variables:
              final_response:
                status: >-
                  {{ 'error' if (read_payload is string and read_payload[:8] ==
                  '{"error"') else 'success' }}
                message: >-
                  {% if read_payload is string and read_payload[:8] ==
                  '{"error"' %}
                    There was a problem reading from the volume.
                  {% else %}
                    Read succeeded.
                  {% endif %}
                result: "{{ read_payload }}"
          - stop: Read complete
            response_variable: final_response
      - conditions:
          - alias: Create (or Update when Key not Exist and Force)
            condition: template
            value_template: >-
              {{ (action_type == 'create' and not key_exists_initial) or
              (action_type == 'update' and not key_exists_initial and
              force_action) }}
        sequence:
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ protect_write and not volume_unmodified }}"
                sequence:
                  - variables:
                      final_response:
                        status: error
                        message: "Protected write blocked: volume was modified. Retry."
                  - stop: Concurrent modification
                    response_variable: final_response
          - event: set_variable_legacy
            event_data:
              key: "{{ key }}"
              value: "{{ new_volume.value }}"
              set_timestamp: "{{ set_timestamp }}"
              volume_entity: "{{ volume_entity }}"
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ accepted_entity_labels | length > 0 }}"
                    alias: Valid Labels
                sequence:
                  - event: set_variable_legacy
                    event_data:
                      key: _label_index
                      value: "{{ updated_label_index }}"
                      set_timestamp: true
                      volume_entity: "{{ volume_entity }}"
                    alias: Update the index
          - alias: Read after Write Verification
            wait_template: >-
              {% set vol = state_attr(volume_entity, 'variables') %} {% if vol
              is mapping and (key in vol) and (vol[key] is mapping) %}
                {{ vol[key].get('value') == new_volume.value }}
              {% else %}
                {{ false }}
              {% endif %}
            timeout: "00:00:01"
            continue_on_timeout: true
          - variables:
              verify_volume: "{{ state_attr(volume_entity, 'variables') | default({}, true) }}"
              verify_entry: >-
                {% if verify_volume is mapping %}{{ verify_volume.get(key, {})
                }}{% else %}{}{% endif %}
              write_verified: >-
                {{ verify_entry is mapping and verify_entry.get('value') ==
                new_volume.value }}
          - variables:
              final_response:
                status: "{{ 'success' if write_verified else 'warning' }}"
                message: |-
                  {% if write_verified %}
                    Created drawer '{{ key }}' (verification confirmed).
                  {% else %}
                    Created drawer '{{ key }}' (verification not confirmed â€” value not yet reflected in state; may be delayed).
                  {% endif %}
                entry:
                  drawer: "{{ key }}"
                  value: "{{ new_volume.value }}"
                  timestamp: >-
                    {{ new_volume.timestamp if new_volume.timestamp is defined
                    else None }}
                verification:
                  confirmed: "{{ write_verified }}"
                warnings: |-
                  {% if dropped_labels | length > 0 %}
                    Warning: {{ dropped_labels | length }} label(s) were ignored: {{ dropped_labels }}
                  {% else %}
                    None
                  {% endif %}
                debug: "{{ debug_labels_block }}"
          - stop: Create fired
            response_variable: final_response
      - conditions:
          - condition: template
            value_template: "{{ action_type == 'update' and key_exists_initial }}"
            alias: Update
        sequence:
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ protect_write and not volume_unmodified }}"
                    alias: "Error - Concurrent Modification Blocked: Modified"
                sequence:
                  - variables:
                      final_response:
                        status: error
                        message: "Protected write blocked: volume was modified. Retry."
                  - stop: Concurrent modification
                    response_variable: final_response
          - event: set_variable_legacy
            event_data:
              key: "{{ key }}"
              value: "{{ new_volume.value }}"
              set_timestamp: "{{ set_timestamp }}"
              volume_entity: "{{ volume_entity }}"
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ accepted_entity_labels | length > 0 }}"
                    alias: Valid Labels
                sequence:
                  - event: set_variable_legacy
                    event_data:
                      key: _label_index
                      value: "{{ updated_label_index }}"
                      set_timestamp: true
                      volume_entity: "{{ volume_entity }}"
                    alias: Update the Index
          - alias: Read after Write Verification (update)
            wait_template: >-
              {% set vol = state_attr(volume_entity, 'variables') %} {% if vol
              is mapping and (key in vol) and (vol[key] is mapping) %}
                {{ vol[key].get('value') == new_volume.value }}
              {% else %}
                {{ false }}
              {% endif %}
            timeout: "00:00:01"
            continue_on_timeout: true
          - variables:
              verify_volume: "{{ state_attr(volume_entity, 'variables') | default({}, true) }}"
              verify_entry: >-
                {% if verify_volume is mapping %}{{ verify_volume.get(key, {})
                }}{% else %}{}{% endif %}
              write_verified: >-
                {{ verify_entry is mapping and verify_entry.get('value') ==
                new_volume.value }}
          - variables:
              final_response:
                status: "{{ 'success' if write_verified else 'warning' }}"
                message: |-
                  {% if write_verified %}
                    Updated drawer '{{ key }}' (verification confirmed).
                  {% else %}
                    Updated drawer '{{ key }}' (verification not confirmed â€” value not yet reflected in state; may be delayed).
                  {% endif %}
                entry:
                  drawer: "{{ key }}"
                  value: "{{ new_entry.value }}"
                  timestamp: >-
                    {{ new_volume.timestamp if new_volume.timestamp is defined
                    else None }}
                verification:
                  confirmed: "{{ write_verified }}"
                warnings: |-
                  {% if dropped_labels | length > 0 %}
                    Warning: {{ dropped_labels | length }} label(s) were ignored: {{ dropped_labels }}
                  {% else %}
                    None
                  {% endif %}
                debug: "{{ debug_labels_block }}"
          - stop: Update fired
            response_variable: final_response
      - conditions:
          - condition: template
            value_template: "{{ action_type == 'delete' and key_exists_initial }}"
            alias: Delete
        sequence:
          - event: remove_variable_legacy
            event_data:
              key: "{{ key }}"
              volume_entity: "{{ volume_entity }}"
          - wait_template: >-
              {% set vol = state_attr(volume_entity, 'variables') | default({},
              true) %} {{ vol is mapping and (key not in vol) }}
            timeout: "00:00:01"
            continue_on_timeout: true
            alias: Read after Delete Verification
          - variables:
              verify_volume: "{{ state_attr(volume_entity, 'variables') | default({}, true) }}"
              delete_verified: "{{ verify_volume is mapping and (key not in verify_volume) }}"
          - variables:
              _index_src: "{{ state_attr(volume_entity, 'variables') | default({}, true) }}"
              _raw_index: |-
                {% if _index_src is mapping %}
                  {{ _index_src.get('_label_index', {}).get('value', {}) }}
                {% else %}
                  {}
                {% endif %}
              pruned_index: |-
                {% if _raw_index is mapping %}
                  {# Build a cleaned copy with `key` removed everywhere #}
                  {% set cleaned = {} %}
                  {% for label, drawers in _raw_index.items() %}
                    {% if drawers is mapping %}
                      {# Nested form: label -> {sub: [drawers]} #}
                      {% set kept_sub = {} %}
                      {% for sub, arr in drawers.items() %}
                        {% set al = arr if (arr is iterable and not arr is string) else [arr] %}
                        {% set cleaned_arr = al | reject('equalto', key) | list %}
                        {% if cleaned_arr | length > 0 %}
                          {% set kept_sub = kept_sub | combine({ sub: cleaned_arr }) %}
                        {% endif %}
                      {% endfor %}
                      {% if kept_sub | length > 0 %}
                        {% set cleaned = cleaned | combine({ label: kept_sub }) %}
                      {% endif %}
                    {% elif drawers is iterable and not drawers is string %}
                      {# Flat list form: label -> [drawers] #}
                      {% set cleaned_list = drawers | reject('equalto', key) | list %}
                      {% if cleaned_list | length > 0 %}
                        {% set cleaned = cleaned | combine({ label: cleaned_list }) %}
                      {% endif %}
                    {% else %}
                      {# Single value fallback #}
                      {% if drawers != key %}
                        {% set cleaned = cleaned | combine({ label: [drawers] }) %}
                      {% endif %}
                    {% endif %}
                  {% endfor %}
                  {{ cleaned }}
                {% else %}
                  {}
                {% endif %}
              index_changed: "{{ pruned_index != _raw_index }}"
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ index_changed }}"
                    alias: Prune needed
                sequence:
                  - event: set_variable_legacy
                    event_data:
                      key: _label_index
                      value: "{{ pruned_index }}"
                      set_timestamp: true
                      volume_entity: "{{ volume_entity }}"
                  - alias: Index prune verification
                    wait_template: >-
                      {% set vol = state_attr(volume_entity, 'variables') |
                      default({}, true) %} {% set raw = vol.get('_label_index',
                      {}).get('value') if vol is mapping else {} %} {% set found
                      = false %} {% if raw is mapping %}
                        {% for label, drawers in raw.items() %}
                          {% if drawers is mapping %}
                            {% for sub, arr in drawers.items() %}
                              {% set al = arr if (arr is iterable and not arr is string) else [arr] %}
                              {% if key in al %}{% set found = true %}{% endif %}
                            {% endfor %}
                          {% elif drawers is iterable and not drawers is string %}
                            {% if key in drawers %}{% set found = true %}{% endif %}
                          {% else %}
                            {% if drawers == key %}{% set found = true %}{% endif %}
                          {% endif %}
                        {% endfor %}
                      {% endif %} {{ not found }}
                    timeout: "00:00:01"
                    continue_on_timeout: true
                  - variables:
                      index_pruned_verified: >-
                        {% set vol = state_attr(volume_entity, 'variables') |
                        default({}, true) %} {% set raw =
                        vol.get('_label_index', {}).get('value') if vol is
                        mapping else {} %} {% set found = false %} {% if raw is
                        mapping %}
                          {% for label, drawers in raw.items() %}
                            {% if drawers is mapping %}
                              {% for sub, arr in drawers.items() %}
                                {% set al = arr if (arr is iterable and not arr is string) else [arr] %}
                                {% if key in al %}{% set found = true %}{% endif %}
                              {% endfor %}
                            {% elif drawers is iterable and not drawers is string %}
                              {% if key in drawers %}{% set found = true %}{% endif %}
                            {% else %}
                              {% if drawers == key %}{% set found = true %}{% endif %}
                            {% endif %}
                          {% endfor %}
                        {% endif %} {{ not found }}
          - variables:
              final_response:
                status: "{{ 'success' if delete_verified else 'warning' }}"
                index_maintenance:
                  pruned: "{{ index_changed }}"
                  verified: "{{ index_pruned_verified if index_changed else true }}"
                message: |-
                  {% if delete_verified %}
                    Deleted drawer '{{ key }}' (verification confirmed).
                  {% else %}
                    Delete requested for '{{ key }}' (verification not confirmed â€” key still present or state not yet updated).
                  {% endif %}
          - stop: Delete fired
            response_variable: final_response
    default:
      - variables:
          final_response:
            status: error
            message: Uncaught Exception. Use 'help' for usage.
      - stop: Invalid parameters
        response_variable: final_response
alias: Zen DojoTools FileCabinet
description: >
  Zen DojoTools FileCabinet (v2.1.0). CabinetVolumes are The Library's storage.
  To use ALWAYS pull a Volume Manifest 'Manifest' (list of all volumes with rich
  metadata) FIRST if you do not already have it loaded to see what's available.
  calling the manifest by issuing a READ - with None, '', or '*' for
  'volume_entity' A directory of a single volume (with labels) can be obtained
  by sending 
    read - valid 'volume_entity' and 'drawer' with None, '', or '*'
  SUPERPOWER! Combine with The Index - Read by label_targets (yes, a list) to
  scan drawers for subjects. STRONG recommendation to HELP() and pull a manifest
  - READ() immediately. EXPERIMENTAL FIELDS Added for future expansion
fields:
  action_type:
    description: "'manifest', 'create', 'read', 'update', 'delete', 'help' (default: help)"
    required: true
    selector:
      select:
        options:
          - manifest
          - create
          - read
          - update
          - delete
          - help
    default: manifest
  volume_entity_id:
    description: >-
      Target volume sensor entity_id (NOT guid, must have a 'variables'
      attribute). Use any of [ None, '', '*'] to return manifest.
    required: false
    selector:
      entity:
        multiple: true
        filter:
          - domain: sensor
    name: volume_entity
  key:
    description: >-
      Drawer to act on.  Drawer names are slugified so 'My Partner' ==
      'my_partner' (required for create/update/delete; blank or '*' returns all
      values)
    required: false
    selector:
      text: null
    name: drawer
  value:
    description: Raw value to store under the drawer (required for create/update)
    required: false
    selector:
      text:
        multiline: true
  set_timestamp:
    description: Boolean. Store ISO timestamp alongside value. Defaults to false.
    required: false
    selector:
      boolean: null
    default: false
  label_input:
    description: >-
      Optional. A list of label/tags to associate with this drawer
      (create/update). Comma- or newline-separated.
    required: false
    selector:
      text:
        multiline: false
    name: labels
  label_targets:
    description: >-
      Optional. When reading, filters the returned data by label(s). Accepts
      list of valid labels, a slngle label, or '*'. Blank returns all.
    required: false
    selector:
      text:
        multiline: false
  show_hidden_volumes:
    selector:
      boolean: {}
    name: Show Hidden Volumes
    description: >-
      Show Hidden / System Volumes (Usually, this is not recommended, only use
      when you're trying to debug, confirm etc.)  System Drawers are always
      hidden.
    required: true
  start:
    description: >-
      Start time in ISO 8601. Userd when searching for entities updated or
      changed after... Defaults to no end date [Experimental - currently unused]
    required: false
    selector:
      text: null
  end:
    description: >-
      End time in ISO 8601. Used when searching for entities updated or changed
      before... Defaults to no end date [Experimental - currently unused]
    required: false
    selector:
      text: null
  filter_domain:
    description: >-
      Filter result list for entities in this domain Defaults to no end date
      [Experimental - currently unused]
    selector:
      text: null
  filter_state_operand:
    description: >-
      Filter result list for entities with this operand (must use filter_op) 
      [Experimental - currently unused]
    selector:
      text: null
    name: Filter Operand
  filter_op:
    description: >-
      Filter entity by entity matching state using this operation with filter
      operand to obtain a filtered result [Experimental - currently unused]
    selector:
      select:
        options:
          - equals
          - contains
          - not
          - above
          - below
          - "true"
          - "false"
    name: Filter Operation
  force_action:
    description: >-
      Set flag true to pre-confirm certain advanced actions - see documentation
      for details
    required: false
    selector:
      boolean: {}
    default: false
icon: mdi:folder-key
