sequence:
  - variables:
      normalized_label_targets: "{{ [] }}"
      resolved_label_drawers: "{{ [] }}"
      resolved_label_entities: "{{ [] }}"
      label_input_list: "{{ [] }}"
      read_volume: "{{ {} }}"
      force_action: "{{ force_action | default(false) }}"
      action_type: "{{ action_type | default('help') }}"
      volume_entity: >-
        {% set _veid = volume_entity_id | default('') %} {% if _veid is string
        %}
          {{ _veid }}
        {% elif _veid is iterable and not _veid is string and _veid | length > 0
        %}
          {{ _veid[0] }}
        {% else %}
          ''
        {% endif %}
      key: "{{ key | default('') | slugify }}"
      raw_value: "{{ value | default('') }}"
      label_input: "{{ label_input | default('') }}"
      label_targets: "{{ label_targets | default('') }}"
      set_timestamp: "{{ set_timestamp | default(false) }}"
      protect_write: "{{ protect_write | default(true) }}"
      now_iso: "{{ now().isoformat() }}"
      is_create: "{{ action_type == 'create' }}"
      is_update: "{{ action_type == 'update' }}"
      is_read: "{{ action_type == 'read' }}"
      is_delete: "{{ action_type == 'delete' }}"
      is_help: "{{ action_type == 'help' }}"
      initial_volume_raw: "{{ state_attr(volume_entity, 'variables') | default({}, true) }}"
      initial_volume: >-
        {% if initial_volume_raw is mapping %}{{ initial_volume_raw }}{% else
        %}{}{% endif %}
      key_exists_initial: "{{ (key != '') and (key in initial_volume) }}"
      prewrite_volume_raw: "{{ state_attr(volume_entity, 'variables') | default({}, true) }}"
      prewrite_volume: >-
        {% if prewrite_volume_raw is mapping %}{{ prewrite_volume_raw }}{% else
        %}{}{% endif %}
      prettify_json_on_fail: "{{ prettify_json_on_fail | default(false) }}"
      label_raw: "{{ label_targets | default('') }}"
      resolved_label_targets: |-
        {{
          (label_raw
            | replace('\n', ',')
            | regex_findall('[^,]+')
            | map('trim')
            | map('lower')
            | list)
        }}
      label_index_map: |-
        {{
          (read_volume.get('_label_index', {}).get('value', {})
              if read_volume is mapping else {})
        }}
      resolved_drawers: >-
        {%- set targets = resolved_label_targets if resolved_label_targets is
        sequence else [] -%}

        {%- set idx = label_index_map if label_index_map is mapping else {} -%}


        {%- set accum = [] -%}


        {# Build one merged list of drawers without using append() #}

        {%- for t in targets %}
          {%- set arr = idx.get(t, []) %}

          {# Normalize arr into clean list #}
          {%- if arr is mapping %}
            {%- set arr = arr.keys() | list %}
          {%- elif arr is iterable and not arr is string %}
            {%- set arr = arr | list %}
          {%- elif arr not in [none, ''] %}
            {%- set arr = [arr] %}
          {%- else %}
            {%- set arr = [] %}
          {%- endif %}

          {# Functional merge — no append — safe union #}
          {%- set accum = (accum + arr) | unique | list %}
        {%- endfor %}

        {% if accum | length == 0 %}
          {{ [] }}
        {% else %}
          {{ accum }}
        {% endif %}
      is_label_mode: |-
        {{
          (resolved_label_targets | length > 0)
        }}
      current_label_index_raw: >-
        {%- set idx = initial_volume.get('_label_index', {}) %} {%- set val =
        idx.get('value') %} {%- if val is mapping %}
          {{ val }}
        {%- elif val is sequence %}
          {%- set mapped = {} -%}
          {%- for label in val if label is string -%}
            {%- set mapped = mapped | combine({ label: [] }) -%}
          {%- endfor -%}
          {{ mapped }}
        {%- else %}
          {} 
        {%- endif %}
      current_label_index: >-
        {%- import 'library_index.jinja' as library_index -%} {{
        library_index.normalize_label_index(current_label_index_raw) }}
      parsed_value: >-
        {% set _v = raw_value | trim %} {% set error = none %} {% set parsed =
        none %} {% if _v == '' %}
          {% set error = "Write failed: Input value is blank." %}
        {% else %}
          {% set temp = _v %}
          {% set try_json = false %}
          {% if temp[:1] in ['{', '['] or temp in ['true', 'false', 'null'] %}
            {% set try_json = true %}
          {% elif temp | regex_match('^-?\\d+$') %}
            {% set try_json = true %}
          {% endif %}
          {% if try_json %}
            {% set parsed = temp | from_json %}
            {% if parsed is none %}
              {% set error = "Write failed: Input value is not valid JSON. Please reformat using proper JSON syntax (e.g., escaped quotes, valid brackets)." %}
            {% endif %}
          {% else %}
            {% set js = temp
              | replace('\\', '\\\\')
              | replace('"', '\\"')
              | replace('\r', '\\r')
              | replace('\n', '\\n')
              | replace('\t', '\\t')
            %}
            {% set wrapped = '"' ~ js ~ '"' %}
            {% set parsed = wrapped | from_json %}
            {% if parsed is none %}
              {% set error = "Write failed: Could not coerce string to JSON—possibly invalid input or encoding." %}
            {% endif %}
          {% endif %}
        {% endif %} {% if error %}
          {{ error }}
        {% else %}
          {{ parsed }}
        {% endif %}
      parsed_entity_labels: |-
        {% if is_create or is_update %}
          {% if label_input is string %}
            {% set s = label_input | replace('\n', ',') %}
            {{
              (
                s
                | regex_findall('[^,]+')
                | map('trim')
                | map('lower')
                | map('slugify')
                | select('string')
                | sort
                | list
              )
            }}
          {% elif label_input is sequence %}
            {{
              (
                label_input
                | map('trim')
                | map('lower')
                | map('slugify')
                | select('string')
                | sort
                | list
              )
            }}
          {% else %}
            []
          {% endif %}
        {% else %}
          []
        {% endif %}
      all_system_labels: |-
        {% if is_create or is_update %}
          {{ labels() | map('lower') | sort | list }}
        {% else %}
          []
        {% endif %}      
      dropped_labels: >-
        {{ parsed_entity_labels | reject('in', all_system_labels) | sort | list
        }}
      accepted_entity_labels: >-
        {{ parsed_entity_labels | select('in', all_system_labels) | sort | list
        }}
      updated_label_index: |-
        {% if (is_create | default(false)) or (is_update | default(false)) %}
          {%- set vol =
                (prewrite_volume if prewrite_volume is mapping else initial_volume)
          -%}
          {%- set current_index = vol.get('_label_index', {}).get('value', {}) -%}
          {%- set current = current_index if current_index is mapping else {} -%}

          {%- set drawer_name = key | lower | slugify -%}
          {%- set new_labels =
                (accepted_entity_labels
                  | map('string')
                  | map('lower')
                  | map('slugify')
                  | list)
          -%}

          {%- set acc = namespace(val = dict(current)) -%}
          {%- for label in new_labels %}
            {%- set entry = acc.val.get(label) %}
            {%- set existing =
                  (entry if entry is iterable and not entry is string else
                   [entry] if entry not in [None, ''] else [])
            -%}
            {%- set acc.val = acc.val | combine({
                  label: (existing + [drawer_name]) | unique | list
                })
            -%}
          {%- endfor %}

          {{ acc.val }}
        {% else %}
          {}
        {% endif %}
      extended_label_index: >-
        {%- set raw = initial_volume.get('_label_index', {}).get('value') -%}
        {%- set index = {} -%}

        {% if raw is mapping %}
          {# Full nested label index (expected case) #}
          {% for _label, drawers in raw.items() %}
            {%- set label = _label | lower | slugify -%}

            {# Normalize drawers to a clean list #}
            {%- if drawers is mapping %}
              {# A dict of drawers → copy keys only, normalized #}
              {%- set clean = drawers.keys() | list -%}

            {%- elif drawers is iterable and not drawers is string %}
              {# Could be list, tuple, generator → normalize #}
              {%- set clean = drawers | list -%}

            {%- else %}
              {# Single string or other scalar #}
              {%- set clean = [drawers] -%}
            {%- endif %}

            {# Force all drawers to become lowercase-slugified names #}
            {%- set clean = clean
                            | map('string')
                            | map('lower')
                            | map('slugify')
                            | list
             -%}

            {# Remove duplicates, ensure real list #}
            {%- set clean = clean | unique | list -%}

            {%- set index = index | combine({ label: clean }) -%}
          {% endfor %}

        {% elif raw is iterable and not raw is string %}
          {# Legacy format: ['label1','label2'] #}
          {% for _label in raw %}
            {%- set label = _label | lower | slugify -%}
            {%- set index = index | combine({ label: ['_unknown_drawer'] }) -%}
          {% endfor %}

        {% else %}
          {# Fallback: rebuild from drawers' meta #}
          {% for drawer, val in initial_volume.items() %}
            {%- set labels = [] -%}
            {% if val is mapping and 'meta' in val and val.meta is mapping %}
              {%- set labels = val.meta.get('entity_labels', []) -%}
            {% elif val is mapping and 'entity_labels' in val %}
              {%- set labels = val.get('entity_labels', []) -%}
            {% endif %}

            {% for _label in labels %}
              {%- set label = _label | lower | slugify -%}
              {%- set existing = index.get(label, []) -%}
              {%- set index = index | combine({
                    label: (existing + [drawer]) 
                           | map('string')
                           | map('lower')
                           | map('slugify')
                           | unique
                           | list
                  })
              -%}
            {% endfor %}
          {% endfor %}
        {% endif %}

        {{ index }}
      new_entry: |-
        {% if is_create or is_update %}
          {% set base = {'value': parsed_value} %}
          {% set with_ts = base | combine({'timestamp': now_iso}) if set_timestamp else base %}
          {% set full = with_ts | combine({'meta': {'entity_labels': accepted_entity_labels | list}}) if accepted_entity_labels | length > 0 else with_ts %}
          {{ full }}
        {% else %}
          {}
        {% endif %}
      new_volume: |-
        {% if is_create or is_update %}
          {% set vol = state_attr(volume_entity, 'variables') | default(initial_volume, true) %}
          {{ vol | combine({
            (key): new_entry,
            '_label_index': {
              'value': updated_label_index,
              'timestamp': now_iso
            }
          }, recursive=true) }}
        {% else %}
          {{ initial_volume }}
        {% endif %}
      volume_unmodified: |-
        {{
          not protect_write or
          (
            (initial_volume_raw | tojson) ==
            (new_volume | tojson)
          )
        }}
      cabinet_volumeinfo: >-
        {% set info = initial_volume.get('AI_Cabinet_VolumeInfo', {}) %} {% if
        info is mapping and info.get('value') is mapping %}
          {{ info.get('value') }}
        {% else %}
          {}
        {% endif %}
      zen_relationships: >-
        {% set z = initial_volume.get('_zen_relationships', {}) %} {% if z is
        mapping and z.get('value') is mapping %}
          {{ z.get('value') }}
        {% else %}
          {}
        {% endif %}
      is_create_path: >-
        {{ is_create_new or is_force_update_new or is_force_create_over_existing
        }}
      is_update_path: |-
        {{
          (is_update and key_exists_initial)
        }}
      is_write_action: |-
        {{
          action_type in ['create','update','delete','move','copy']
        }}
      json_parse_failed: |-
        {{
          (parsed_value is string and parsed_value.startswith('Write failed'))
          or
          (parsed_value is mapping and (parsed_value.get('error','') | string).startswith('Write failed'))
        }}
      health_blocked: |-
        {{
          (state_attr(volume_entity, 'health') or {}).get('status') == 'error'
          or (state_attr(volume_entity, 'health') or {}).get('guid_mismatch', false)
          or not (state_attr(volume_entity, 'health') or {}).get('writeable', true)
          or (
                (state_attr(volume_entity, 'health') or {}).get('storage_warning', false)
                and not force_action
             )
        }}
      is_force_create_over_existing: |-
        {{
          action_type == 'create'
          and key != ''
          and key_exists_initial
          and force_action
        }}
  - choose:
      - conditions:
          - condition: template
            value_template: |
              {{
                (parsed_value is string and parsed_value.startswith('Write failed'))
                or
                (parsed_value is mapping and (parsed_value.get('error','') | string).startswith('Write failed'))
              }}
            alias: Error - Fatal JSON Parsing
        sequence:
          - data:
              level: error
              message: >
                ZenDojoTools FileCabinet: FATAL — JSON parse error, write
                aborted. Key: {{ key }} | Volume: {{ volume_entity }} Parsed
                Value: {{ parsed_value }}
            action: system_log.write
          - stop: JSON Parse Failure
  - choose:
      - conditions:
          - condition: template
            value_template: |
              {{ action_type in ['create','update','delete','move','copy'] }}
            alias: Is a 'write' action
        sequence:
          - variables:
              vol_health: "{{ state_attr(volume_entity, 'health') or {} }}"
              h_status: "{{ vol_health.get('status','') }}"
              h_mismatch: "{{ vol_health.get('guid_mismatch', false) }}"
              h_writeable: "{{ vol_health.get('writeable', true) }}"
              h_storage_warning: "{{ vol_health.get('storage_warning', false) }}"
              health_blocked: |
                {{
                  (h_status == 'error')
                  or h_mismatch
                  or (not h_writeable)
                  or (h_storage_warning and not force_action)
                }}
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ health_blocked }}"
                    alias: "Error: Not Healthy"
                sequence:
                  - variables:
                      final_response:
                        status: error
                        message: "Write blocked: Volume not healthy."
                        health_snapshot:
                          status: "{{ h_status }}"
                          mismatch: "{{ h_mismatch }}"
                          writeable: "{{ h_writeable }}"
                          storage_warning: "{{ h_storage_warning }}"
                          force_action: "{{ force_action }}"
                  - stop: Health-blocked write
                    response_variable: final_response
  - choose:
      - conditions:
          - condition: template
            value_template: >-
              {{ action_type in ['create','update'] and (key == '' or raw_value
              == '') }}
            alias: Error - Create Update, Drawer (Key) or Value Missing
        sequence:
          - variables:
              final_response:
                status: error
                message: >-
                  For '{{ action_type }}', you must supply both 'key' and
                  'value'.
          - stop: Missing key/value
            response_variable: final_response
      - conditions:
          - condition: template
            value_template: "{{ action_type == 'delete' and key == '' }}"
            alias: Error - Delete, Drawer (Key) Missing
        sequence:
          - variables:
              final_response:
                status: error
                message: For 'delete', you must supply a 'key'.
          - stop: Missing key for delete
            response_variable: final_response
      - conditions:
          - alias: Error - Update, Drawer (Key) does not exist
            condition: template
            value_template: >-
              {{ action_type == 'update' and not key_exists_initial and not
              force_action }}
        sequence:
          - variables:
              final_response:
                status: error
                message: "Cannot update: key '{{ key }}' does not exist."
          - stop: Key not found
            response_variable: final_response
      - conditions:
          - alias: Error — Create, Drawer Exists and Not Force_Action
            condition: template
            value_template: |-
              {{
                action_type == 'create'
                and key != ''
                and key_exists_initial
                and not force_action
              }}
        sequence:
          - variables:
              final_response:
                status: error
                message: >-
                  Cannot create: key '{{ key }}' exists. Use Update or retry
                  with override approval using force_action. (Will be logged)
          - stop: Drawer Exists and not force_action
            response_variable: final_response
      - conditions:
          - condition: template
            value_template: "{{ action_type == 'help' }}"
            alias: Help
        sequence:
          - variables:
              final_response:
                status: info
                message: Zen DojoTools File Cabinet Help
                actions:
                  manifest: >-
                    Use MANIFEST function for the Volume Manifest (list all
                    volumes) Errors may silently return Manifest - if you
                    unexpectedly got a manifest... Yeah...
                  create: >-
                    Optional set_timestamp, protect_write, label_input Requires
                    'drawer' and 'value'; drawer must exist; must write WHOLE
                    drawer' at once. AS AN OVERWRITE. 'value' must be valid
                    JSON; will attempt to parse, error returned on failure.
                  read: |-
                    manifest: >-
                      Set 'volume_entity' to '*'
                      Same as Volume Manifest (all volumes)
                    volume: >-
                      directory: >-
                        Set 'volume_entity' to [your_volume_entity]
                        Set 'drawer' to any of [None, '', '*']
                        to obtain volume directory
                      content: >-
                        Set 'volume_entity' to [your_volume_entity]
                        set 'drawer' to [your_valid_drawer]
                      special: >-
                        Use label_targets for filtered read.
                  update: >-
                    Requires 'drawer' and 'value'; drawer must exist; must write
                    WHOLE drawer' at once. 'value' must be valid JSON; will
                    attempt to parse.  With force_action, will silently create
                    drawer. error returned on failure.
                  delete: Requires 'drawer'
                  copy: >-
                    Requires (source) 'drawer' only the first in list will be
                    accepted, all others will be dropped
                      'destination drawer', 'destination cabinet'
                    optional 'force_action' Attempts to move a drawer from
                    source ot dest.  Must be valid Cabinet, Source and Dest
                    drawer. Use force_action to overwrite destination drawer
                    with action.
                  move: >-
                    Requirements and usage identical to Copy,  will also attempt
                    a delete source after copy.
                  help: Returns help
                about:
                  version: 3.7.0
                  branch: beta
                  manual: |-
                    summary: >
                      The Zen DojoTools File Cabinet is your go-to tool for managing data in volumes.
                      Volumes are digital storage units made of drawers that hold organized chunks
                      of information. When using the controller, first locate the correct volume and
                      drawer for your data task. Always maintain data integrity by reading current data
                      before updating to avoid accidental overwrites. Volumes and drawers come
                      with labels, indexes, and metadata applied at the drawer level—these are key
                      to making data searchable and easily manageable. Think of drawers as
                      entities in a many-to-many relationship with labels, allowing flexible,
                      powerful querying across multiple volumes.
                      Decide between read-optimized and write-optimized data structures based on
                      usage.
                      Read-optimized for stable, quickly accessible nested data via dotted
                      notation, and write-optimized for isolated, rapidly changing contexts like
                      game states. Ownership and role distinctions segment data access across
                      multiple volumes, keeping data secure and context-appropriate.
                      The volume index performs table scans across all accessible volumes to
                      find labels and locate data, highlighting the critical importance of
                      thorough labeling. Metadata at the drawer level enriches data with context,
                      enhancing findability and decision-making.
                      With this approach, data stays organized, accessible, and scalable, enabling
                      efficient management for all smart home or AI project needs. Use this guide
                      to keep your data game solid, agile, and Friday-approved.    
                    author: person.friday date: 6/8/2025
                defaults:
                  protect_write: true
          - stop: Returning help
            response_variable: final_response
      - conditions:
          - alias: Read by Label
            condition: template
            value_template: |
              {{ 
                (label_targets | default('') | trim | length > 0)
              }}
        sequence:
          - variables:
              always_hide_drawers:
                - AI_Cabinet_VolumeInfo
              read_volume: "{{ state_attr(volume_entity, 'variables') | default({}, true) }}"
              vol: "{{ read_volume if read_volume is mapping else {} }}"
              normalized_label_targets: |-
                {{
                  (
                    (label_targets | default('') | replace('\n', ','))
                    | regex_findall('[^,]+')
                    | map('trim')
                    | map('lower')
                    | map('slugify')
                    | list
                  )
                }}
              label_index: |-
                {{
                  (
                    vol.get('_label_index', {}).get('value', {})
                    if vol is mapping else {}
                  )
                }}
              resolved_label_drawers: |-
                {# Step 1: detect bad python literal #}
                {% set is_python_literal =
                  (label_index is string)
                  and ("{" in label_index)
                  and ("'" in label_index)
                  and not ('"' in label_index)
                %}

                {# Step 2: fix it if needed #}
                {% if is_python_literal %}
                  {% set json_str = label_index
                    | replace("'", '"')
                    | replace("None", "null")
                    | replace("True", "true")
                    | replace("False", "false")
                  %}
                  {% set idx = json_str | from_json %}
                {% elif label_index is string %}
                  {% set idx = label_index | from_json %}
                {% else %}
                  {% set idx = label_index %}
                {% endif %}

                {% set targets = (normalized_label_targets | list) %}
                {% set ns = namespace(out=[]) %}

                {# Iterate through targets #}
                {% for t in targets %}
                  {% set raw_arr = idx[t] | default('__MISS__') %}

                  {# normalize arr #}
                  {% if raw_arr is mapping %}
                    {% set arr = raw_arr.keys() | list %}
                  {% elif raw_arr is iterable and raw_arr is not string and raw_arr != '__MISS__' %}
                    {% set arr = raw_arr | list %}
                  {% elif raw_arr not in [none, '', '__MISS__'] %}
                    {% set arr = [raw_arr] %}
                  {% else %}
                    {% set arr = [] %}
                  {% endif %}

                  {# merge #}
                  {% set ns.out = (ns.out + arr) | unique | list %}
                {% endfor %}

                {{ ns.out }}
              is_label_mode: "{{ normalized_label_targets | length > 0 }}"
              read_payload: |-
                {% set vol = read_volume if read_volume is mapping else {} %}
                {% if vol|length == 0 %}
                  {{ {"error": "Volume attribute missing or empty."} | tojson }}
                {% else %}
                  {% set targets = normalized_label_targets %}
                  {% set drawers = resolved_label_drawers %}
                  {% set has_targets = targets|length > 0 %}
                  {% if has_targets %}
                    {% set ns = namespace(out={}) %}
                    {% for d in drawers %}
                      {% if d in vol and d not in always_hide_drawers and not (d[:1] in ['_', '.']) %}
                        {% set ns.out = ns.out | combine({ d: vol[d] }) %}
                      {% endif %}
                    {% endfor %}
                    {{
                      {
                        "mode": "label",
                        "label_targets": targets,
                        "resolved_drawers": drawers,
                        "count": ns.out|length,
                        "drawers": ns.out,
                        "message": (
                          "No drawers found for requested labels."
                          if ns.out|length == 0
                          else "OK"
                        )
                      } | tojson
                    }}
                  {% else %}
                    {{ {
                      "error": "Label mode requested but no labels found.",
                      "label_targets": targets
                    } | tojson }}
                  {% endif %}
                {% endif %}
          - variables:
              final_response:
                status: >-
                  {{ 'error' if (read_payload is string and read_payload[:8] ==
                  '{"error"') else 'success' }}
                message: >-
                  {% if read_payload is string and read_payload[:8] ==
                  '{"error"' %}
                    There was a problem reading from the volume.
                  {% else %}
                    Read succeeded.
                  {% endif %}
                result: "{{ read_payload }}"
          - stop: Read complete
            response_variable: final_response
      - conditions:
          - alias: Directory - Read all drawers in volume
            condition: template
            value_template: |
              {{ action_type == 'read'
                 and ((label_targets | trim) == '')
                 and (volume_entity not in ['', '*', None])
                 and (key in ['', None, '*']) }}
        sequence:
          - variables:
              ignore_label_prefixes:
                - _
                - .
              always_hide_drawers:
                - AI_Cabinet_VolumeInfo
              read_volume: "{{ state_attr(volume_entity, 'variables') | default({}, true) }}"
              raw_drawers: >-
                {% if read_volume is mapping %}{{ read_volume.keys() | list }}{%
                else %}[]{% endif %}
              read_label_index: |-
                {% if read_volume %}
                  {{ read_volume.get('_label_index', {}).get('value', []) }}
                {% else %}
                  []
                {% endif %}
              read_filtered_manifest: >-
                {%- import 'library_index.jinja' as library_index -%}

                {%- set cabs_json = library_index.parse_index_command('AI Data
                Storage Cabinet') -%}

                {%- set fixed_json = cabs_json | replace("['", '["')  |
                replace("']", '"]') | replace("', '", '", "') | trim %}

                {%- set cabs = fixed_json | from_json -%}

                {%- set sensors = states['sensor'] | map(attribute='entity_id')
                | list -%}

                {%- set fcabs = intersect(sensors, cabs) -%}


                {%- set ns = namespace(filtered={}) %}

                {%- for cab_entity in fcabs %}
                  {%- set variables = state_attr(cab_entity, 'variables') %}
                  {%- if variables and variables.get('AI_Cabinet_VolumeInfo') and variables['AI_Cabinet_VolumeInfo'].get('value') %}
                    {%- set cab_id = variables['AI_Cabinet_VolumeInfo']['value'].get('id', cab_entity) %}
                    {%- set ns.filtered = ns.filtered | combine({
                      (cab_entity): variables['AI_Cabinet_VolumeInfo']['value']
                    }) %}
                  {%- endif %}
                {%- endfor %}

                {{ ns.filtered }}
              parsed_key: "{{ key | default('', true) | trim | lower }}"
              initial_volume: "{{ read_volume if read_volume is mapping else {} }}"
              read_payload: >-

                {# Ensure read_volume is a mapping; else fallback to empty dict
                #}

                {% set safe_read_volume = read_volume if read_volume is mapping
                else {} %}


                {% if safe_read_volume | length == 0 %}
                  {{ {'error': 'Volume attribute missing or empty.'} | tojson }}
                {% elif parsed_key in ['', '*'] %}
                  {%- set raw_drawers = safe_read_volume.keys() | list | default([]) %}
                  {%- set filtered_drawers_ns = namespace(items=[]) %}
                  {%- for d in raw_drawers %}
                    {%- if d not in always_hide_drawers and not (d[:1] == '_' or d[:1] == '.') %}
                      {%- set val = safe_read_volume.get(d, {}) %}
                      {%- set val_value = val.get('value') if val is mapping else {} %}
                      {%- if val is mapping and val_value is mapping and val_value.get('mount_point', false) %}
                        {%- set mp_target = (
                            val_value.get('target_entity_id')
                            if val_value.get('target_entity_id')
                            else val_value.get('target_volume_id')
                            if val_value.get('target_volume_id')
                            else '?'
                          ) -%}
                        {%- set drawer_name = d ~ ' [mount:' ~ mp_target ~ ']' %}
                      {%- else %}
                        {%- set drawer_name = d %}
                      {%- endif %}
                      {%- set filtered_drawers_ns.items = filtered_drawers_ns.items + [drawer_name] %}
                    {%- endif %}
                  {%- endfor %}
                  {%- set drawer_list = filtered_drawers_ns.items %}

                  {{
                    {
                      'drawers': drawer_list,
                      'label_index': read_label_index
                    } | tojson
                  }}
                {% endif %}
          - variables:
              final_response:
                status: >-
                  {{ 'error' if (read_payload is string and read_payload[:8] ==
                  '{"error"') else 'success' }}
                message: >-
                  {% if read_payload is string and read_payload[:8] ==
                  '{"error"' %}
                    There was a problem reading drawers in the volume.
                  {% else %}
                    Directory read succeeded.
                  {% endif %}
                result: "{{ read_payload }}"
          - stop: Volume directory read complete
            response_variable: final_response
      - conditions:
          - alias: Read
            condition: template
            value_template: |+
              {% set is_direct_read =
                   (action_type == 'read')
                   and (volume_entity not in [None, '', '*'])
                   and (key not in [None, '', '*'])
              %}

              {% set has_labels = normalized_label_targets is iterable
                                  and (normalized_label_targets | length) > 0 %}

              {% set is_label_read =
                   (action_type == 'read')
                   and has_labels
              %}

              {{ is_direct_read or is_label_read }}

        sequence:
          - variables:
              ignore_label_prefixes:
                - _
                - .
              always_hide_drawers:
                - AI_Cabinet_VolumeInfo
              read_volume: "{{ state_attr(volume_entity, 'variables') | default({}, true) }}"
              parsed_key: "{{ key | default('', true) | trim | lower }}"
              vol: "{{ read_volume if read_volume is mapping else {} }}"
              label_index: |-
                {{
                  (
                    vol.get('_label_index', {}).get('value', {})
                    if vol is mapping else {}
                  )
                }}
              read_payload: |-
                {% if vol | length == 0 %}
                  {{ {"error": "Volume attribute missing or empty."} | tojson }}
                {% else %}

                  {# --------------------------------------------------
                     CASE 1: DIRECTORY LISTING ("", "*")
                     -------------------------------------------------- #}
                  {% if parsed_key in ['', '*'] %}
                    {% set drawers = [] %}
                    {% for d in vol.keys() | list %}
                      {% if d not in always_hide_drawers and not (d[:1] in ['_', '.']) %}
                        {% set drawers = drawers + [d] %}
                      {% endif %}
                    {% endfor %}
                    {{ {"drawers": drawers, "label_index": label_index} | tojson }}

                  {# --------------------------------------------------
                     CASE 2: DIRECT KEY READ
                     -------------------------------------------------- #}
                  {% elif parsed_key in vol %}
                    {{ {parsed_key: vol[parsed_key]} | tojson }}

                  {# --------------------------------------------------
                     CASE 3: NOT FOUND
                     -------------------------------------------------- #}
                  {% else %}
                    {{ {"error": "Requested drawer not found in volume."} | tojson }}
                  {% endif %}

                {% endif %}
          - variables:
              final_response:
                status: >-
                  {{ 'error' if (read_payload is string and read_payload[:8] ==
                  '{"error"') else 'success' }}
                message: >-
                  {% if read_payload is string and read_payload[:8] ==
                  '{"error"' %}
                    There was a problem reading from the volume.
                  {% else %}
                    Read succeeded.
                  {% endif %}
                result: "{{ read_payload }}"
          - stop: Read complete
            response_variable: final_response
      - conditions:
          - alias: Manifest - Read Volume( '', '*' )
            condition: template
            value_template: |2
                {{
                  action_type == 'manifest'
                  or (
                    action_type == 'read'
                    and (label_targets | trim) == ''
                    and (volume_entity in ['', '*', None])
                  )
                }}
        sequence:
          - action: script.zen_dojotools_manifest
            metadata: {}
            data:
              show_hidden_volumes: "{{ show_hidden_volumes }}"
            response_variable: final_response
          - stop: Manifest read complete
            response_variable: final_response
      - conditions:
          - alias: Create (or Update when Key not Exist and Force)
            condition: template
            value_template: |-
              {{
                 is_create_new
                 or is_force_update_new
                 or is_force_create_over_existing
              }}
        sequence:
          - choose:
              - conditions:
                  - condition: template
                    value_template: |2-
                        {{
                          protect_write
                          and not force_action
                          and not volume_unmodified
                        }}
                sequence:
                  - variables:
                      final_response:
                        status: error
                        message: "Protected write blocked: volume was modified. Retry."
                  - stop: Concurrent modification
                    response_variable: final_response
          - event: set_variable_legacy
            event_data:
              key: "{{ key }}"
              value: "{{ new_entry.value }}"
              set_timestamp: "{{ set_timestamp }}"
              volume_entity: "{{ volume_entity }}"
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ accepted_entity_labels | length > 0 }}"
                    alias: Valid Labels
                sequence:
                  - alias: Update the index
                    event: set_variable_legacy
                    event_data:
                      key: _label_index
                      value: "{{ updated_label_index }}"
                      set_timestamp: true
                      volume_entity: "{{ volume_entity }}"
          - alias: Read after Write Verification
            wait_template: |-
              {% set vol = state_attr(volume_entity, 'variables') %}
              {% if vol is mapping %}
                {% set entry = vol.get(key) %}
                {{ entry is mapping }}
              {% else %}
                false
              {% endif %}
            timeout: "00:00:02"
            continue_on_timeout: true
          - variables:
              verify_volume: "{{ state_attr(volume_entity, 'variables') | default({}, true) }}"
              verify_entry: |-
                {% if verify_volume is mapping %}
                  {{ verify_volume.get(key, {}) }}
                {% else %}
                  {}
                {% endif %}
              write_verified: |-
                {{
                  verify_entry is mapping
                  and verify_entry.get('value') == new_entry.value
                }}
          - variables:
              final_response:
                status: "{{ 'success' if write_verified else 'warning' }}"
                message: |-
                  {% if write_verified %}
                    Created drawer '{{ key }}' (verification confirmed).
                  {% else %}
                    Created drawer '{{ key }}' (value written but verification delayed).
                  {% endif %}
                entry:
                  drawer: "{{ key }}"
                  value: "{{ new_entry.value }}"
                  timestamp: >-
                    {{ new_entry.timestamp if new_entry.timestamp is defined
                    else None }}
                verification:
                  confirmed: "{{ write_verified }}"
                warnings: |-
                  {% if dropped_labels | length > 0 %}
                    Warning: {{ dropped_labels | length }} ignored label(s): {{ dropped_labels }}
                  {% else %}
                    None
                  {% endif %}
          - stop: Create fired
            response_variable: final_response
      - conditions:
          - alias: Update
            condition: template
            value_template: >
              {{ action_type == 'update' and key_exists_initial and not
              is_force_update_new }}
        sequence:
          - choose:
              - conditions:
                  - alias: "Error - Concurrent Modification Blocked: Modified"
                    condition: template
                    value_template: |2
                        {{
                          protect_write
                          and not force_action
                          and not volume_unmodified
                        }}
                sequence:
                  - variables:
                      final_response:
                        status: error
                        message: "Protected write blocked: volume was modified. Retry."
                  - stop: Concurrent modification
                    response_variable: final_response
          - event: set_variable_legacy
            event_data:
              key: "{{ key }}"
              value: "{{ new_entry.value }}"
              set_timestamp: "{{ set_timestamp }}"
              volume_entity: "{{ volume_entity }}"
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ accepted_entity_labels | length > 0 }}"
                    alias: Valid Labels
                sequence:
                  - alias: Update the Index
                    event: set_variable_legacy
                    event_data:
                      key: _label_index
                      value: "{{ updated_label_index }}"
                      set_timestamp: true
                      volume_entity: "{{ volume_entity }}"
          - alias: Read after Write Verification (update)
            wait_template: |-
              {% set vol = state_attr(volume_entity, 'variables') %}
              {% if vol is mapping %}
                {% set entry = vol.get(key) %}
                {{ entry is mapping }}
              {% else %}
                false
              {% endif %}
            timeout: "00:00:02"
            continue_on_timeout: true
          - variables:
              verify_volume: "{{ state_attr(volume_entity, 'variables') | default({}, true) }}"
              verify_entry: |-
                {% if verify_volume is mapping %}
                  {{ verify_volume.get(key, {}) }}
                {% else %}
                  {}
                {% endif %}
              write_verified: |-
                {{
                  verify_entry is mapping
                  and verify_entry.get('value') == new_entry.value
                }}
          - variables:
              final_response:
                status: "{{ 'success' if write_verified else 'warning' }}"
                message: |-
                  {% if write_verified %}
                    Updated drawer '{{ key }}' (verification confirmed).
                  {% else %}
                    Updated drawer '{{ key }}' (value written but verification delayed).
                  {% endif %}
                entry:
                  drawer: "{{ key }}"
                  value: "{{ new_entry.value }}"
                  timestamp: >-
                    {{ new_entry.timestamp if new_entry.timestamp is defined
                    else None }}
                verification:
                  confirmed: "{{ write_verified }}"
                warnings: |-
                  {% if dropped_labels | length > 0 %}
                    Warning: {{ dropped_labels | length }} ignored label(s): {{ dropped_labels }}
                  {% else %}
                    None
                  {% endif %}
          - stop: Update fired
            response_variable: final_response
      - conditions:
          - condition: template
            value_template: "{{ action_type == 'delete' and key_exists_initial }}"
            alias: Delete
        sequence:
          - event: remove_variable_legacy
            event_data:
              key: "{{ key }}"
              volume_entity: "{{ volume_entity }}"
          - wait_template: >-
              {% set vol = state_attr(volume_entity, 'variables') | default({},
              true) %} {{ vol is mapping and (key not in vol) }}
            timeout: "00:00:01"
            continue_on_timeout: true
            alias: Read after Delete Verification
          - variables:
              verify_volume: "{{ state_attr(volume_entity, 'variables') | default({}, true) }}"
              delete_verified: "{{ verify_volume is mapping and (key not in verify_volume) }}"
          - variables:
              _index_src: "{{ state_attr(volume_entity, 'variables') | default({}, true) }}"
              _raw_index: |-
                {% if _index_src is mapping %}
                  {{ _index_src.get('_label_index', {}).get('value', {}) }}
                {% else %}
                  {}
                {% endif %}
              pruned_index: |-
                {% if _raw_index is mapping %}
                  {# Build a cleaned copy with `key` removed everywhere #}
                  {% set cleaned = {} %}
                  {% for label, drawers in _raw_index.items() %}
                    {% if drawers is mapping %}
                      {# Nested form: label -> {sub: [drawers]} #}
                      {% set kept_sub = {} %}
                      {% for sub, arr in drawers.items() %}
                        {% set al = arr if (arr is iterable and not arr is string) else [arr] %}
                        {% set cleaned_arr = al | reject('equalto', key) | list %}
                        {% if cleaned_arr | length > 0 %}
                          {% set kept_sub = kept_sub | combine({ sub: cleaned_arr }) %}
                        {% endif %}
                      {% endfor %}
                      {% if kept_sub | length > 0 %}
                        {% set cleaned = cleaned | combine({ label: kept_sub }) %}
                      {% endif %}
                    {% elif drawers is iterable and not drawers is string %}
                      {# Flat list form: label -> [drawers] #}
                      {% set cleaned_list = drawers | reject('equalto', key) | list %}
                      {% if cleaned_list | length > 0 %}
                        {% set cleaned = cleaned | combine({ label: cleaned_list }) %}
                      {% endif %}
                    {% else %}
                      {# Single value fallback #}
                      {% if drawers != key %}
                        {% set cleaned = cleaned | combine({ label: [drawers] }) %}
                      {% endif %}
                    {% endif %}
                  {% endfor %}
                  {{ cleaned }}
                {% else %}
                  {}
                {% endif %}
              index_changed: "{{ pruned_index != _raw_index }}"
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ index_changed }}"
                    alias: Prune needed
                sequence:
                  - event: set_variable_legacy
                    event_data:
                      key: _label_index
                      value: "{{ pruned_index }}"
                      set_timestamp: true
                      volume_entity: "{{ volume_entity }}"
                  - alias: Index prune verification
                    wait_template: >-
                      {% set vol = state_attr(volume_entity, 'variables') |
                      default({}, true) %} {% set raw = vol.get('_label_index',
                      {}).get('value') if vol is mapping else {} %} {% set found
                      = false %} {% if raw is mapping %}
                        {% for label, drawers in raw.items() %}
                          {% if drawers is mapping %}
                            {% for sub, arr in drawers.items() %}
                              {% set al = arr if (arr is iterable and not arr is string) else [arr] %}
                              {% if key in al %}{% set found = true %}{% endif %}
                            {% endfor %}
                          {% elif drawers is iterable and not drawers is string %}
                            {% if key in drawers %}{% set found = true %}{% endif %}
                          {% else %}
                            {% if drawers == key %}{% set found = true %}{% endif %}
                          {% endif %}
                        {% endfor %}
                      {% endif %} {{ not found }}
                    timeout: "00:00:01"
                    continue_on_timeout: true
                  - variables:
                      index_pruned_verified: >-
                        {% set vol = state_attr(volume_entity, 'variables') |
                        default({}, true) %} {% set raw =
                        vol.get('_label_index', {}).get('value') if vol is
                        mapping else {} %} {% set found = false %} {% if raw is
                        mapping %}
                          {% for label, drawers in raw.items() %}
                            {% if drawers is mapping %}
                              {% for sub, arr in drawers.items() %}
                                {% set al = arr if (arr is iterable and not arr is string) else [arr] %}
                                {% if key in al %}{% set found = true %}{% endif %}
                              {% endfor %}
                            {% elif drawers is iterable and not drawers is string %}
                              {% if key in drawers %}{% set found = true %}{% endif %}
                            {% else %}
                              {% if drawers == key %}{% set found = true %}{% endif %}
                            {% endif %}
                          {% endfor %}
                        {% endif %} {{ not found }}
          - variables:
              final_response:
                status: "{{ 'success' if delete_verified else 'warning' }}"
                index_maintenance:
                  pruned: "{{ index_changed }}"
                  verified: "{{ index_pruned_verified if index_changed else true }}"
                message: |-
                  {% if delete_verified %}
                    Deleted drawer '{{ key }}' (verification confirmed).
                  {% else %}
                    Delete requested for '{{ key }}' (verification not confirmed — key still present or state not yet updated).
                  {% endif %}
          - stop: Delete fired
            response_variable: final_response
      - conditions:
          - condition: template
            value_template: "{{ action_type in ['move', 'copy'] }}"
            alias: Move/Copy Drawer
        sequence:
          - variables:
              dest_cabinet: "{{ destination_cabinet | default('') }}"
              dest_drawer: "{{ destination_drawer | default('') | slugify }}"
              dest_volume: "{{ state_attr(dest_cabinet, 'variables') | default({}, true) }}"
              src_drawer_data: "{{ initial_volume.get(key, {}) }}"
              src_drawer_value: >-
                {{ src_drawer_data.get('value') if src_drawer_data is mapping
                else src_drawer_data }}
              can_write_dest: >-
                {{ not protect_write or (state_attr(dest_cabinet,
                'variables').get(dest_drawer) is none) or force_action }}
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ dest_cabinet == '' or dest_drawer == '' }}"
                sequence:
                  - variables:
                      final_response:
                        status: error
                        message: Missing destination_cabinet or destination_drawer.
                  - stop: Incomplete destination
                    response_variable: final_response
              - conditions:
                  - condition: template
                    value_template: "{{ not can_write_dest }}"
                sequence:
                  - variables:
                      final_response:
                        status: error
                        message: >-
                          Target drawer '{{ dest_drawer }}' already exists in
                          '{{ dest_cabinet }}'. Use force_action to overwrite.
                  - stop: Overwrite blocked
                    response_variable: final_response
          - event: set_variable_legacy
            event_data:
              key: "{{ dest_drawer }}"
              value: "{{ src_drawer_value }}"
              set_timestamp: true
              volume_entity: "{{ dest_cabinet }}"
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ accepted_entity_labels | length > 0 }}"
                    alias: Valid Labels
                sequence:
                  - alias: Update the Index
                    event: set_variable_legacy
                    event_data:
                      key: _label_index
                      value: "{{ updated_label_index }}"
                      set_timestamp: true
                      volume_entity: "{{ dest_cabinet }}"
          - wait_template: >-
              {% set vol = state_attr(dest_cabinet, 'variables') | default({},
              true) %} {{ vol.get(dest_drawer, {}).get('value') ==
              src_drawer_value }}
            timeout: "00:00:01"
            continue_on_timeout: true
          - variables:
              write_verified: >-
                {% set vol = state_attr(dest_cabinet, 'variables') | default({},
                true) %} {{ vol.get(dest_drawer, {}).get('value') ==
                src_drawer_value }}
          - choose:
              - conditions:
                  - condition: template
                    value_template: "{{ action_type == 'move' and key_exists_initial }}"
                    alias: Move - Source Delete Required
                sequence:
                  - event: remove_variable_legacy
                    event_data:
                      key: "{{ key }}"
                      volume_entity: "{{ volume_entity }}"
                  - wait_template: >-
                      {% set vol = state_attr(volume_entity, 'variables') |
                      default({}, true) %} {{ key not in vol }}
                    timeout: "00:00:01"
                    continue_on_timeout: true
                  - variables:
                      _raw_index: >-
                        {{ initial_volume.get('_label_index', {}).get('value') |
                        default({}) }}
                      _index_src: >-
                        {{ state_attr(volume_entity, 'variables') | default({},
                        true) }}
                      pruned_index: |-
                        {% if _raw_index is mapping %}
                          {# Build a cleaned copy with `key` removed everywhere #}
                          {% set cleaned = {} %}
                          {% for label, drawers in _raw_index.items() %}
                            {% if drawers is mapping %}
                              {# Nested form: label -> {sub: [drawers]} #}
                              {% set kept_sub = {} %}
                              {% for sub, arr in drawers.items() %}
                                {% set al = arr if (arr is iterable and not arr is string) else [arr] %}
                                {% set cleaned_arr = al | reject('equalto', key) | list %}
                                {% if cleaned_arr | length > 0 %}
                                  {% set kept_sub = kept_sub | combine({ sub: cleaned_arr }) %}
                                {% endif %}
                              {% endfor %}
                              {% if kept_sub | length > 0 %}
                                {% set cleaned = cleaned | combine({ label: kept_sub }) %}
                              {% endif %}
                            {% elif drawers is iterable and not drawers is string %}
                              {# Flat list form: label -> [drawers] #}
                              {% set cleaned_list = drawers | reject('equalto', key) | list %}
                              {% if cleaned_list | length > 0 %}
                                {% set cleaned = cleaned | combine({ label: cleaned_list }) %}
                              {% endif %}
                            {% else %}
                              {# Single value fallback #}
                              {% if drawers != key %}
                                {% set cleaned = cleaned | combine({ label: [drawers] }) %}
                              {% endif %}
                            {% endif %}
                          {% endfor %}
                          {{ cleaned }}
                        {% else %}
                          {}
                        {% endif %}
                      index_changed: "{{ _raw_index != pruned_index }}"
                  - choose:
                      - conditions:
                          - condition: template
                            value_template: "{{ index_changed }}"
                            alias: Prune needed
                        sequence:
                          - event: set_variable_legacy
                            event_data:
                              key: _label_index
                              value: "{{ pruned_index }}"
                              set_timestamp: true
                              volume_entity: "{{ volume_entity }}"
                          - alias: Index prune verification
                            wait_template: >-
                              {% set vol = state_attr(volume_entity,
                              'variables') | default({}, true) %} {% set raw =
                              vol.get('_label_index', {}).get('value') if vol is
                              mapping else {} %} {% set found = false %} {% if
                              raw is mapping %}
                                {% for label, drawers in raw.items() %}
                                  {% if drawers is mapping %}
                                    {% for sub, arr in drawers.items() %}
                                      {% set al = arr if (arr is iterable and not arr is string) else [arr] %}
                                      {% if key in al %}{% set found = true %}{% endif %}
                                    {% endfor %}
                                  {% elif drawers is iterable and not drawers is string %}
                                    {% if key in drawers %}{% set found = true %}{% endif %}
                                  {% else %}
                                    {% if drawers == key %}{% set found = true %}{% endif %}
                                  {% endif %}
                                {% endfor %}
                              {% endif %} {{ not found }}
                            timeout: "00:00:01"
                            continue_on_timeout: true
                          - variables:
                              index_pruned_verified: >-
                                {% set vol = state_attr(volume_entity,
                                'variables') | default({}, true) %} {% set raw =
                                vol.get('_label_index', {}).get('value') if vol
                                is mapping else {} %} {% set found = false %} {%
                                if raw is mapping %}
                                  {% for label, drawers in raw.items() %}
                                    {% if drawers is mapping %}
                                      {% for sub, arr in drawers.items() %}
                                        {% set al = arr if (arr is iterable and not arr is string) else [arr] %}
                                        {% if key in al %}{% set found = true %}{% endif %}
                                      {% endfor %}
                                    {% elif drawers is iterable and not drawers is string %}
                                      {% if key in drawers %}{% set found = true %}{% endif %}
                                    {% else %}
                                      {% if drawers == key %}{% set found = true %}{% endif %}
                                    {% endif %}
                                  {% endfor %}
                                {% endif %} {{ not found }}
          - variables:
              final_response:
                status: "{{ 'success' if write_verified else 'warning' }}"
                message: |-
                  {% if write_verified %}
                    Drawer '{{ key }}' {{ action_type }}d to '{{ dest_drawer }}' in '{{ dest_cabinet }}'.
                  {% else %}
                    {{ action_type | title }} completed but write verification failed or delayed.
                  {% endif %}
                verification:
                  confirmed: "{{ write_verified }}"
          - stop: Move/Copy complete
            response_variable: final_response
    default:
      - variables:
          final_response:
            status: error
            message: Uncaught Exception. Use 'help' for usage.
      - stop: Invalid parameters
        response_variable: final_response
alias: Zen DojoTools FileCabinet (RC1)
description: >-
  Zen DojoTools FileCabinet (v3.9.0 RC1) 100% More Health, No Bad JSON! No more
  ghost Writes

  CabinetVolumes are The Library's storage. To use ALWAYS pull a Volume Manifest
  'Manifest' (list of all volumes with rich metadata) FIRST if you do not
  already have it loaded to see what's available. calling the manifest by
  issuing a READ - with None, '', or '*' for 'volume_entity' A directory of a
  single volume (with labels) can be obtained by sending 
    read - valid 'volume_entity' and 'drawer' with None, '', or '*'
  SUPERPOWER! Combine with The Index - Read by label_targets (yes, a list) to
  scan drawers for subjects. STRONG recommendation to HELP() and pull a manifest
  - READ() immediately.

  IMPORTANT: Read By Label is currently limited to ONE cabinet at a time.
fields:
  action_type:
    description: >-
      'manifest', 'create', 'read', 'update', 'delete', 'move', 'copy', 'help'
      (default: help)
    required: true
    selector:
      select:
        options:
          - manifest
          - create
          - read
          - update
          - delete
          - move
          - copy
          - help
    default: manifest
  volume_entity_id:
    description: >-
      Target volume entity_id (NOT guid, must be valid cabinet). Use any of [
      None, '', '*'] to return manifest.  On move / copy only accepts first
      entry as source.
    required: false
    selector:
      entity:
        multiple: true
        filter:
          - domain: sensor
    name: volume_entity
  key:
    description: >-
      Drawer to act on.  Drawer names are slugified so 'My Partner' ==
      'my_partner' (required for create/update/delete; blank or '*' returns all
      values)
    required: false
    selector:
      text: null
    name: drawer
  value:
    description: Raw value to store under the drawer (required for create/update)
    required: false
    selector:
      text:
        multiline: true
  set_timestamp:
    description: Boolean. Store ISO timestamp alongside value. Defaults to false.
    required: false
    selector:
      boolean: null
    default: false
  label_input:
    description: >-
      Optional. A list of label/tags to associate with this drawer
      (create/update). Comma- or newline-separated.
    required: false
    selector:
      text:
        multiline: false
    name: labels
  label_targets:
    description: >-
      Optional. When reading, filters the returned data by label(s). Accepts
      list of valid labels, a slngle label, or '*'. Blank returns all.
    required: false
    selector:
      text:
        multiline: false
  show_hidden_volumes:
    selector:
      boolean: {}
    name: Show Hidden Volumes
    description: >-
      Show Hidden / System Volumes (Usually, this is not recommended, only use
      when you're trying to debug, confirm etc.)  System Drawers are always
      hidden.
    required: true
  start:
    description: >-
      Start time in ISO 8601. Userd when searching for entities updated or
      changed after... Defaults to no end date [Experimental - currently unused]
    required: false
    selector:
      text: null
  end:
    description: >-
      End time in ISO 8601. Used when searching for entities updated or changed
      before... Defaults to no end date [Experimental - currently unused]
    required: false
    selector:
      text: null
  filter_domain:
    description: >-
      Filter result list for entities in this domain Defaults to no end date
      [Experimental - currently unused]
    selector:
      text: null
  filter_state_operand:
    description: >-
      Filter result list for entities with this operand (must use filter_op) 
      [Experimental - currently unused]
    selector:
      text: null
    name: Filter Operand
  filter_op:
    description: >-
      Filter entity by entity matching state using this operation with filter
      operand to obtain a filtered result [Experimental - currently unused]
    selector:
      select:
        options:
          - equals
          - contains
          - not
          - above
          - below
          - "true"
          - "false"
    name: Filter Operation
  force_action:
    description: >-
      Set flag true to pre-confirm certain advanced actions - see documentation
      for details
    required: false
    selector:
      boolean: {}
    default: false
  destination_cabinet:
    selector:
      entity: {}
    name: Destination Cabinet
    description: Target Cabinet, REQUIRED for Move / Copy Actions. Must be valid cabinet.
  destination_drawer:
    selector:
      text: null
    name: Destination Drawer
    description: >-
      Target Drawer, REQUIRED for Move / Copy Actions. Drawer name will be
      slugified - 'My Partner' == 'my_partner' 
icon: mdi:folder-key
